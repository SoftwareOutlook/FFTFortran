\documentclass[a4]{article}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{lscape}
\usepackage{hyperref}
\usepackage{amssymb,longtable}
\usepackage[centertags]{amsmath}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{newlfont}
\usepackage{caption}
\usepackage{epsfig}
\newcommand{\norm}[1]{\left\Vert#1\right\Vert}

\textwidth  17.17cm
\textheight 23.4cm
\oddsidemargin -0.7mm
\evensidemargin -0.7mm
\def\baselinestretch{1.1}

\topmargin -8.4mm

\begin{document}

\title{Software Outlook: FFT Benchmarks for Fortran Codes }
\author{H. Sue Thorne}

\maketitle

%\begin{abstract}
%The abstract text goes here.
%\end{abstract}

\section{Introduction}
As part of the 2018/19 Software Outlook Work Plan, we will be benchmarking 
a number of different Fast Four Transform (FFT) libraries with bindings for
Fortran. The attributes of the different libraries are given in 
Section~\ref{Sec:libs}. Assuming indexing starts at 1, the discrete 1D Fourier transform of a vector $x$ of length $n$ is defined as
\begin{equation}\label{Eqn:fft}
  z(k) = \sum_{m=1}^{n} x(m) \exp(-2\pi i (k-1) (m-1) / n), \quad l=1,\ldots,n.
\end{equation}

\subsection{Half-complex format}
For input data that is purely real, the discrete Fourier transform satisfies 
the ``Hermitian'' redundancy: in 1D, if $x$ is a real array, then $z$ computed 
via (\ref{Eqn:fft}) will be a complex array satisfying
$$z(k) = \left[z(n-k+2)\right]^*, \quad k=2,\ldots,n.$$ Also note that the 
imaginary part of $z(1)$ is always 0; for $n$ even, the imaginary part of 
$z(n/2 + 1) $ is also always 0. This special symmetry in $z$ is known as 
\textit{half-complex} format and means that it can 
be stored more efficiently using a real array $y$ of length $n.$ The method of 
storing $z$ in $y$ will vary according to the library being used but one 
possibility is to define the values of $y$ as
\begin{eqnarray*}
y(1) & = & real(z(1)),\\
y(i) & = & real(z(i)), \quad i=2,\ldots,\lfloor n/2 \rfloor +1,\\
y(n-i+2) & = & imag(z(i)), \quad i=2,\ldots, \lfloor (n+1)/2  \rfloor.
\end{eqnarray*} 
Half-complex format can 
be extended to more dimensions. Note that if the input vector $x$ is 
half-complex format, then $z$ will be a real vector.


\section{1D Benchmark}
Let $A$ be a 2D array with dimensions $n_1\times n_2$ and there be $q$ 
2D arrays $B_i$ that are the same size as $A$ and satisfy 
$\sum_i^q \left[B_i(j,k)  \right]^2 = 1$ for each $j=1,\ldots,n_1$ and 
$k=1,\ldots,n_2.$  The general benchmark will take the form of 
Algorithm~\ref{Alg:1D}, where $comp\_mult(A,B_i)$ is defined to be 
component-wise multiplication of $A$ with $B_i;$  $comp\_div(H_i,B_i)$ 
is defined to be component-wise division of $H_i$ by $B_i;$ $\texttt{FFT}$ 
is the discrete Fast Fourier Transform and $\texttt{IFFT}$ is the 
discrete inverse Fast Fourier Transform.


\begin{algorithm}\caption{1D Benchmark}\label{Alg:1D}
\noindent \hrulefill

\begin{algorithmic}


\FOR {$i=1,\ldots,q$}

\STATE $C_i = comp\_mult(A,B_i)$

\FOR {$k=1,\ldots,n_2$}


\STATE $D_k = C_i(:,k)$

\STATE $F_k = \texttt{FFT}(D_k)$

\IF {do\_inverse}

\STATE $G_k = \texttt{IFFT}(F_k)$

\STATE $H(:,k) = G_k$

\ENDIF


\ENDFOR

\IF {do\_inverse}

\STATE $J_i = comp\_div(H_i,B_i) $

\STATE $abs\_err = \norm{A-J_i}_2$

\ENDIF

\ENDFOR

\end{algorithmic}
\noindent \hrulefill

\end{algorithm}

\section{2D Benchmark}
Let $A$ be a 3D array with dimensions $n_1\times n_2\times n_3$ and there be $q$ 
3D arrays $B_i$ that are the same size as $A$ and satisfy 
$\sum_i^q \left[B_i(j,k,l)  \right]^2 = 1$ for each $j=1,\ldots,n_1,$ 
$k=1,\ldots,n_2$ and $l=1,\ldots,n_3.$  The benchmark will take the form of 
Algorithm~\ref{Alg:2D}, where $comp\_mult(A,B_i)$ is defined to be 
component-wise multiplication of $A$ with $B_i;$  $comp\_div(H_i,B_i)$ 
is defined to be component-wise division of $H_i$ by $B_i;$ $\texttt{FFT}$ 
is the discrete Fast Fourier Transform and $\texttt{IFFT}$ is the 
discrete inverse Fast Fourier Transform. This benchmark is designed to imitate 
some of the workload done in CCP\_PETMR's SIRF code.


\begin{algorithm}\caption{2D Benchmark}\label{Alg:2D}
\noindent \hrulefill

\begin{algorithmic}


\FOR {$i=1,\ldots,q$}

\STATE $C_i = comp\_mult(A,B_i)$

\FOR {$l=1,\ldots,n_3$}


\STATE $D_l = C_i(:,:,l)$

\STATE $F_l = \texttt{FFT}(D_l)$

\IF {do\_inverse}

\STATE $G_l = \texttt{IFFT}(F_l)$

\STATE $H(:,l) = G_l$

\ENDIF


\ENDFOR

\IF {do\_inverse}

\STATE $J_i = comp\_div(H_i,B_i) $

\STATE $abs\_err = \norm{A-J_i}_2$

\ENDIF

\ENDFOR

\end{algorithmic}
\noindent \hrulefill

\end{algorithm}

\section{3D Benchmark}
Let $A$ be a 3D array with dimensions $n_1\times n_2\times n_3$ and there be $q$ 
3D arrays $B_i$ that are the same size as $A$ and satisfy 
$\sum_i^q \left[B_i(j,k,l)  \right]^2 = 1$ for each $j=1,\ldots,n_1,$ 
$k=1,\ldots,n_2$ and $l=1,\ldots,n_3.$  The benchmark will take the form of 
Algorithm~\ref{Alg:2D}, where $comp\_mult(A,B_i)$ is defined to be 
component-wise multiplication of $A$ with $B_i;$  $comp\_div(H_i,B_i)$ 
is defined to be component-wise division of $H_i$ by $B_i;$ $\texttt{FFT}$ 
is the discrete Fast Fourier Transform and $\texttt{IFFT}$ is the 
discrete inverse Fast Fourier Transform. 


\begin{algorithm}\caption{2D Benchmark}\label{Alg:2D}
\noindent \hrulefill

\begin{algorithmic}


\FOR {$i=1,\ldots,q$}

\STATE $C_i = comp\_mult(A,B_i)$



\STATE $F_i = \texttt{FFT}(C_i)$

\IF {do\_inverse}

\STATE $H_i = \texttt{IFFT}(F_i)$

\STATE $J_i = comp\_div(H_i,B_i) $

\STATE $abs\_err = \norm{A-J_i}_2$

\ENDIF

\ENDFOR

\end{algorithmic}
\noindent \hrulefill

\end{algorithm}

\section{FFT Libraries}\label{Sec:libs}

We will compare the libraries listed in Table~\ref{Tbl:libs}. 
The datatypes listed are real (R), complex (C) and half-complex (H). The column 
"Dimensions" indicates the dimensions for which interfaces are provided. Lower 
dimensions can be input by calling the interface for higher dimensions and 
setting the dimension size to 1 for the additional dimensions.

\begin{table}[h]
\begin{center}
\begin{small}
\begin{tabular}{|l|c|c|c|l|l|c|}
\hline
\textbf{Library} & \textbf{Data types} & \textbf{Dimensions} & \textbf{Valid $n$} & \textbf{Parallelism} & \textbf{License} & \textbf{Citation} \\ \hline
FFTE & R $\rightarrow$ H & 2,3   & $2^a\times 3^b \times 5^c$ & OpenMP, MPI,  & Open source & \cite{FFTE} \\
     & C $\rightarrow$ C & 1,2,3 & & CUDA & & \\
     & H $\rightarrow$ R & 2,3   & & & & \\ \hline
FFTW & R $\rightarrow$ H & Any   & Any but optimised for  & Multithreading, & GPL v3 & \cite{FFTW} \\
     & C $\rightarrow$ C & Any      & $2^a\times 3^b\times 5^c\times 7^d\times 11^e\times 13^f$ &  MPI & & \\
     & H $\rightarrow$ R & Any      & with $e+f = 0$ or $1$ & & & \\ \hline
MKL  & R $\rightarrow$ H & Any   & Any & Multithreading, & Intel Simplified & \cite{MKL} \\
     & C $\rightarrow$ C & Any      & & MPI & Software License & \\
     & H $\rightarrow$ R & Any   & & & & \\ \hline
P3DFFT & R $\rightarrow$ H & 3   & Any & OpenMP, MPI & GPL v3 & \cite{P3DFFT} \\
     & H $\rightarrow$ R & 3   & & & & \\ \hline
P3DFFT++ & R $\rightarrow$ H & 1,3   & Any & MPI & GPL v3 & \cite{P3DFFT} \\
     & C $\rightarrow$ C &  1,3     & & &  & \\
     & H $\rightarrow$ R & 1,3   & & & & \\ \hline

\end{tabular}
\caption{Libraries being benchmarked.  For ``valid $n$'', the values $a,$ $b,$ $c,$ $d,$ $e$ and $f$ are all assumed to the non-negative integers.}\label{Tbl:libs}
\end{small}
\end{center}
\end{table}


\bibliographystyle{siam}
\bibliography{bib2017}


\end{document}
